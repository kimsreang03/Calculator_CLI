Element* init_element(char* value, char type){

  Element* element = calloc(1, sizeof(struct ELEMENTS));
  element->value = value;
  element->type = type;

  return element;
}

Scanner* init_scanner(char* input){
  Scanner* scanner = calloc(1, sizeof(struct SCANNER));
  scanner->input = input;
  scanner->input_size = strlen(input);
  scanner->index = 0;
  scanner->current = input[scanner->index];

  return scanner;
}

void scanner_advance(Scanner* scanner){
  if(scanner->index < scanner->input_size && scanner->current != '\0'){
    scanner->index++;
    scanner->current = scanner->input[scanner->index];
  }
}

Element* scanner_advance_current(Scanner* scanner, int type){
    char* value = calloc(2, sizeof(char));
    value[0] = scanner->current;
    value[1] = '\0';
    scanner_advance(scanner);
    return init_element(value, type);
}

void scanner_skip_whitespace(Scanner* scanner){
  while(scanner->current == 13 || scanner->current == 10 || scanner->current == ' ' || scanner->current == '\t'){
    scanner_advance(scanner);
  }
}// skip whitespace: ' ' \n '\t'

Element* scanner_constant(Scanner* scanner){
  char* value = calloc(1, sizeof(char)); // allocates for value
  while(isdigit(scanner->current) || scanner->current == '.'){
    value = realloc(value, (strlen(value) + 2)*sizeof(char)); // allocates more memory for value
    strcat(value, (char[]){scanner->current, 0});
    scanner_advance(scanner);
  }
  return init_element(value, CONSTANT); // return constant as string type
} //scan for constant

Element* scanner_next_element(Scanner* scanner){

  while(scanner->current != '\0'){
    scanner_skip_whitespace(scanner);
    if(isdigit(scanner->current)) return scanner_constant(scanner);

    //return type of each element
    switch(scanner->current){
      case '+': return scanner_advance_current(scanner, PLUS_SIGN); break;
      case '-': return scanner_advance_current(scanner, MINUS_SIGN); break;
      case '*': return scanner_advance_current(scanner, MULTIPLY_SIGN); break;
      case '/': return scanner_advance_current(scanner, DIVIDE_SIGN); break;
      case '=': return scanner_advance_current(scanner, EQUAL_SIGN); break;
      case '(': return scanner_advance_current(scanner, LEFT_PARENTHESIS); break;
      case ')': return scanner_advance_current(scanner, RIGHT_PARENTHESIS); break;
      case '[': return scanner_advance_current(scanner, LEFT_BRACKET); break;
      case ']': return scanner_advance_current(scanner, RIGHT_BRACKET); break;
      case '{': return scanner_advance_current(scanner, LEFT_BRACE); break;
      case '}': return scanner_advance_current(scanner, RIGHT_BRACE); break;
      case '<': return scanner_advance_current(scanner, LESSTHAN_SIGN); break;
      case '>': return scanner_advance_current(scanner, GREATERTHAN_SIGN); break;
      case '^': return scanner_advance_current(scanner, CARET); break;
      case '!': return scanner_advance_current(scanner, EXCLAMATION); break;
      case '%': return scanner_advance_current(scanner, PERCENT_SIGN); break;

      default: {
        printf("[scanner]: unexpected character %c\n", scanner->current);
        scanner_advance(scanner);
      }
      break;
    }
  }

  return init_element(0, EOI); //END OF FILE
}
typedef struct SCANNER{

  char* input;
  size_t input_size;
  char current;
  unsigned int index;

}Scanner;

typedef struct ELEMENTS{

  char* value;
  enum{
    CONSTANT, // 0: number
    PLUS_SIGN, // 1: +
    MINUS_SIGN, // 2: -
    MULTIPLY_SIGN, // 3: *
    DIVIDE_SIGN, // 4: /
    EQUAL_SIGN, // 5: =
    LEFT_PARENTHESIS, // 6: (
    RIGHT_PARENTHESIS, // 7: )
    LEFT_BRACKET, // 8: [
    RIGHT_BRACKET,// 9: ]
    LEFT_BRACE, // 10: {
    RIGHT_BRACE, // 11: }
    LESSTHAN_SIGN, // 12: <
    GREATERTHAN_SIGN, // 13: >
    CARET, // 14: ^
    EXCLAMATION, // 15: !
    PERCENT_SIGN, // 16: %
    EOI, // 17: END OF INPUT
  }type;

}Element;

Element* init_element(char* value, char type);

Scanner* init_scanner(char* input);

void scanner_advance(Scanner* scanner);

Element* scanner_advance_current(Scanner* scanner, int type);

void scanner_skip_whitespace(Scanner* scanner);

Element* scanner_constant(Scanner* scanner);

Element* scanner_next_element(Scanner* scanner);

// + - * / 1 2 3` 4`

float result = 0;

bool hasPlusMinus = false;

for(short i = 0; i < operator_size; i++){
  if(operator[i] == PLUS_SIGN || operator[i] == MINUS_SIGN)
    hasPlusMinus = true;
}

if(operator_size == constant_size - 1 && hasPlusMinus){

  int i = 0;
  float* new_constant = calloc(0, sizeof(float));
  short* new_operater = calloc(0, sizeof(short));
  short new_operater_size = 0;
  short new_constant_size = 0;
  short skipped = 0;



  while(i < operator_size){

    if(operator[i-skipped] == PLUS_SIGN || operator[i-skipped] == MINUS_SIGN){
      // copy the plus_sign and minus_sign into new array
      new_operater = realloc(new_operater, (i+1-skipped)*sizeof(short));
      new_operater[i-skipped] = operator[i-skipped];
      new_operater_size++;

      new_constant = realloc(new_constant, (i+1-skipped)*sizeof(float));
      new_constant[i-skipped] = constant[i-skipped];
      new_constant_size++;
      i++;
      printf("yes\n");
    }
    if(operator[i-skipped] == MULTIPLY_SIGN || operator[i-skipped] == DIVIDE_SIGN){
      while(operator[i-skipped] == MULTIPLY_SIGN || operator[i-skipped] == DIVIDE_SIGN){

        if(operator[i-skipped] == MULTIPLY_SIGN)
          constant[i+1-skipped] = constant[i-skipped] * constant[i+1-skipped];
        if(operator[i-skipped] == DIVIDE_SIGN)
          constant[i+1-skipped] = constant[i-skipped] / constant[i+1-skipped];
        skipped++;
        i += 2;
        printf("yeah\n");

      }

      new_constant = realloc(new_constant, (i-skipped)*sizeof(float));
      new_constant[i-1-skipped] = constant[i-skipped];
      new_constant_size++;
    }

  }

  printf("new operater size: %d\n", new_operater_size);
  printf("new constant size: %d\n", new_constant_size);
  for(int i = 0; i < new_constant_size; i++){
   printf("new_number_: %f\n", new_constant[i]);
  }
  for(int i = 0; i < new_operater_size; i++){
   printf("new_operator_: %d\n", new_operater[i]);
  }
  printf("\n\n");

  short a = 1;
  while(a < operator_size){ // 2<4
    if(operator[operator_size-a] == MINUS_SIGN || operator[operator_size-a] == PLUS_SIGN){
      new_operater = realloc(new_operater, (new_operater_size+1)*sizeof(short));
      new_operater[new_operater_size] = operator[operator_size-a];
      new_operater_size++;

      new_constant = realloc(new_constant, (new_constant_size+1)*sizeof(float));
      new_constant[new_constant_size] = constant[constant_size-1];
      new_constant_size++;
      break;
    }
    a++;
  }

  //print new constant and operater
  for(int i = 0; i < new_constant_size; i++){
   printf("new_number_: %f\n", new_constant[i]);
  }
  for(int i = 0; i < new_operater_size; i++){
   printf("new_operator_: %d\n", new_operater[i]);
  }

 //calculate new expression
  short k = 0;
  while(k < new_operater_size){

    if(new_operater[k] == PLUS_SIGN)
      new_constant[k+1] = new_constant[k] + new_constant[k+1];
    if(new_operater[k] == MINUS_SIGN)
      new_constant[k+1] = new_constant[k] - new_constant[k+1];
    k++;
  }
  result = new_constant[k];
  free(new_constant);
  free(new_operater);
}else if(operator_size == constant_size - 1 ){
  //calculate  expression
   short k = 0;
   while(k < operator_size){

     if(operator[k] == MULTIPLY_SIGN)
       constant[k+1] = constant[k] * constant[k+1];
     if(operator[k] == DIVIDE_SIGN)
       constant[k+1] = constant[k] / constant[k+1];

     k++;
   }
   result = constant[k];
}


return result;
}
